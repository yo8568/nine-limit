/**
 * @copyright 2013 Sonia Keys
 * @copyright 2016 commenthol
 * @license MIT
 * @module saturnring
 */
/**
 * Saturnrings: Chapter 45, The Ring of Saturn
 */

import base from './base';
import coord from './coord';
import nutation from './nutation';
import planetposition from './planetposition';

/**
 * Ring computes quantities of the ring of Saturn.
 *
 *  B  Saturnicentric latitude of the Earth referred to the plane of the ring.
 *  Bʹ  Saturnicentric latitude of the Sun referred to the plane of the ring.
 *  ΔU  Difference between Saturnicentric longitudes of the Sun and the Earth.
 *  P  Geometric position angle of the northern semiminor axis of the ring.
 *  aEdge  Major axis of the out edge of the outer ring.
 *  bEdge  Minor axis of the out edge of the outer ring.
 *
 * All results in radians.
 */
export function ring(jde, earth, saturn) {
  // (jde float64, earth, saturn *pp.V87Planet)  (B, Bʹ, ΔU, P, aEdge, bEdge float64)
  var _cl = cl(jde, earth, saturn),
      f1 = _cl[0],
      f2 = _cl[1];

  var _f = f1(),
      ΔU = _f[0],
      B = _f[1];

  var _f2 = f2(),
      Bʹ = _f2[0],
      P = _f2[1],
      aEdge = _f2[2],
      bEdge = _f2[3];

  return [B, Bʹ, ΔU, P, aEdge, bEdge];
}

/**
 * UB computes quantities required by illum.Saturn().
 *
 * Same as ΔU and B returned by Ring().  Results in radians.
 */
export function ub(jde, earth, saturn) {
  // (jde float64, earth, saturn *pp.V87Planet)  (ΔU, B float64)
  var _cl2 = cl(jde, earth, saturn),
      f1 = _cl2[0],
      f2 = _cl2[1]; // eslint-disable-line no-unused-vars


  return f1();
}

/**
 * cl splits the work into two closures.
 */
function cl(jde, earth, saturn) {
  // (jde float64, earth, saturn *pp.V87Planet)  (f1 func() (ΔU, B float64),
  // f2 func() (Bʹ, P, aEdge, bEdge float64))
  var p = Math.PI / 180;
  var i = void 0,
      Ω = void 0;
  var l0 = void 0,
      b0 = void 0,
      R = void 0;
  var Δ = 9.0;
  var λ = void 0,
      β = void 0;
  var si = void 0,
      ci = void 0,
      sβ = void 0,
      cβ = void 0,
      sB = void 0;
  var sbʹ = void 0,
      cbʹ = void 0,
      slʹΩ = void 0,
      clʹΩ = void 0;
  var f1 = function f1() {
    // (ΔU, B float64)
    // (45.1), p. 318
    var T = base.J2000Century(jde);
    i = base.horner(T, 28.075216 * p, -0.012998 * p, 0.000004 * p);
    Ω = base.horner(T, 169.50847 * p, 1.394681 * p, 0.000412 * p);
    // Step 2.0
    var earthPos = earth.position(jde);
    R = earthPos.range;
    var fk5 = planetposition.toFK5(earthPos.lon, earthPos.lat, jde);
    l0 = fk5.lon;
    b0 = fk5.lat;

    var _base$sincos = base.sincos(l0),
        sl0 = _base$sincos[0],
        cl0 = _base$sincos[1];

    var sb0 = Math.sin(b0);
    // Steps 3, 4.0
    var l = void 0,
        b = void 0,
        r = void 0,
        x = void 0,
        y = void 0,
        z = void 0;
    var f = function f() {
      var τ = base.lightTime(Δ);
      var saturnPos = saturn.position(jde - τ);
      r = saturnPos.range;
      var fk5 = planetposition.toFK5(saturnPos.lon, saturnPos.lat, jde);
      l = fk5.lon;
      b = fk5.lat;

      var _base$sincos2 = base.sincos(l),
          sl = _base$sincos2[0],
          cl = _base$sincos2[1];

      var _base$sincos3 = base.sincos(b),
          sb = _base$sincos3[0],
          cb = _base$sincos3[1];

      x = r * cb * cl - R * cl0;
      y = r * cb * sl - R * sl0;
      z = r * sb - R * sb0;
      Δ = Math.sqrt(x * x + y * y + z * z);
    };
    f();
    f();
    // Step 5.0
    λ = Math.atan2(y, x);
    β = Math.atan(z / Math.hypot(x, y));
    // First part of step 6.0
    si = Math.sin(i);
    ci = Math.cos(i);
    sβ = Math.sin(β);
    cβ = Math.cos(β);
    sB = si * cβ * Math.sin(λ - Ω) - ci * sβ;
    var B = Math.asin(sB); // return value
    // Step 7.0
    var N = 113.6655 * p + 0.8771 * p * T;
    var lʹ = l - 0.01759 * p / r;
    var bʹ = b - 0.000764 * p * Math.cos(l - N) / r;
    // Setup for steps 8, 9.0
    sbʹ = Math.sin(bʹ);
    cbʹ = Math.cos(bʹ);
    slʹΩ = Math.sin(lʹ - Ω);
    clʹΩ = Math.cos(lʹ - Ω);
    // Step 9.0

    var _base$sincos4 = base.sincos(λ - Ω),
        sλΩ = _base$sincos4[0],
        cλΩ = _base$sincos4[1];

    var U1 = Math.atan2(si * sbʹ + ci * cbʹ * slʹΩ, cbʹ * clʹΩ);
    var U2 = Math.atan2(si * sβ + ci * cβ * sλΩ, cβ * cλΩ);
    var ΔU = Math.abs(U1 - U2); // return value
    return [ΔU, B];
  };
  var f2 = function f2() {
    // (Bʹ, P, aEdge, bEdge) {
    // Remainder of step 6.0
    var aEdge = 375.35 / 3600 * p / Δ; // return value
    var bEdge = aEdge * Math.abs(sB); // return value
    // Step 8.0
    var sBʹ = si * cbʹ * slʹΩ - ci * sbʹ;
    var Bʹ = Math.asin(sBʹ); // return value
    // Step 10.0

    var _nutation$nutation = nutation.nutation(jde),
        Δψ = _nutation$nutation[0],
        Δε = _nutation$nutation[1];

    var ε = nutation.meanObliquity(jde) + Δε;
    // Step 11.0
    var λ0 = Ω - Math.PI / 2;
    var β0 = Math.PI / 2 - i;
    // Step 12.0

    var _base$sincos5 = base.sincos(l0 - λ),
        sl0λ = _base$sincos5[0],
        cl0λ = _base$sincos5[1];

    λ += 0.005693 * p * cl0λ / cβ;
    β += 0.005693 * p * sl0λ * sβ;
    // Step 13.0
    λ0 += Δψ;
    λ += Δψ;
    // Step 14.0
    var eq = new coord.Ecliptic(λ0, β0).toEquatorial(ε);
    var _ref = [eq.ra, eq.dec],
        α0 = _ref[0],
        δ0 = _ref[1];

    eq = new coord.Ecliptic(λ, β).toEquatorial(ε);
    var _ref2 = [eq.ra, eq.dec],
        α = _ref2[0],
        δ = _ref2[1];
    // Step 15.0

    var _base$sincos6 = base.sincos(δ0),
        sδ0 = _base$sincos6[0],
        cδ0 = _base$sincos6[1];

    var _base$sincos7 = base.sincos(δ),
        sδ = _base$sincos7[0],
        cδ = _base$sincos7[1];

    var _base$sincos8 = base.sincos(α0 - α),
        sα0α = _base$sincos8[0],
        cα0α = _base$sincos8[1];

    var P = Math.atan2(cδ0 * sα0α, sδ0 * cδ - cδ0 * sδ * cα0α); // return value
    return [Bʹ, P, aEdge, bEdge];
  };
  return [f1, f2];
}

export default {
  ring: ring,
  ub: ub
};