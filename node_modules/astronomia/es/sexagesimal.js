function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @copyright 2013 Sonia Keys
 * @copyright 2016 commenthol
 * @license MIT
 * @module sexagesimal
 */
/**
 * Sexagesimal functions
 */

/**
 * Angle represents a general purpose angle.
 * Unit is radians.
 */
export var Angle = function () {
  /**
  * constructs a new Angle value from sign, degree, minute, and second
  * components.
  * __One argument__
  * @param {Number} angle - (float) angle in radians
  * __Four arguments__
  * @param {Boolean} neg - sign, true if negative (required to attribute -0°30')
  * @param {Number} d - (int) degree
  * @param {Number} m - (int) minute
  * @param {Number} s - (float) second
  */
  function Angle(neg, d, m, s) {
    _classCallCheck(this, Angle);

    if (arguments.length === 1) {
      this.angle = neg;
    } else {
      this.setDMS(neg, d, m, s);
    }
  }

  /**
   * SetDMS sets the value of an FAngle from sign, degree, minute, and second
   * components.
   * The receiver is returned as a convenience.
   * @param {Boolean} neg - sign, true if negative
   * @param {Number} d - (int) degree
   * @param {Number} m - (int) minute
   * @param {Number} s - (float) second
   * @returns {Angle}
   */


  Angle.prototype.setDMS = function setDMS() {
    var neg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var d = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var m = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.0;

    this.angle = DMSToDeg(neg, d, m, s) * Math.PI / 180;
    return this;
  };

  /**
   * sets angle
   * @param {Number} angle - (float) angle in radians
   * @returns {Angle}
   */


  Angle.prototype.setAngle = function setAngle(rad) {
    this.angle = rad;
    return this;
  };

  /**
   * Rad returns the angle in radians.
   * @returns {Number} angle in radians
   */


  Angle.prototype.rad = function rad() {
    return this.angle;
  };

  /**
   * Deg returns the angle in degrees.
   * @returns {Number} angle in degree
   */


  Angle.prototype.deg = function deg() {
    return this.angle * 180 / Math.PI;
  };

  /**
   * toDMS converts to parsed sexagesimal angle component.
   */


  Angle.prototype.toDMS = function toDMS() {
    return degToDMS(this.deg());
  };

  /**
   * Print angle in degree using `d°m´s.ss″`
   * @param {Number} precision - precision of `s.ss`
   * @returns {String}
   */


  Angle.prototype.toString = function toString(precision) {
    var _toDMS = this.toDMS(),
        neg = _toDMS[0],
        d = _toDMS[1],
        m = _toDMS[2],
        s = _toDMS[3];

    s = round(s, precision).toString().replace(/^0\./, '.');
    var str = (neg ? '-' : '') + (d + '°') + (m + '′') + (s + '″');
    return str;
  };

  /**
   * Print angle in degree using `d°.ff`
   * @param {Number} precision - precision of `.ff`
   * @returns {String}
   */


  Angle.prototype.toDegString = function toDegString(precision) {
    var _modf = modf(this.deg()),
        i = _modf[0],
        s = _modf[1];

    s = round(s, precision).toString().replace(/^0\./, '.');
    var str = i + '°' + s;
    return str;
  };

  return Angle;
}();

/**
 * HourAngle represents an angle corresponding to angular rotation of
 * the Earth in a specified time.
 *
 * Unit is radians.
 */
export var HourAngle = function (_Angle) {
  _inherits(HourAngle, _Angle);

  function HourAngle() {
    _classCallCheck(this, HourAngle);

    return _possibleConstructorReturn(this, _Angle.apply(this, arguments));
  }

  /**
  * NewHourAngle constructs a new HourAngle value from sign, hour, minute,
  * and second components.
  * @param {Boolean} neg
  * @param {Number} h - (int)
  * @param {Number} m - (int)
  * @param {Number} s - (float)
  */
  // constructor (neg, h, m, s) {
  // super(neg, h, m, s)
  // }

  /**
   * SetDMS sets the value of an FAngle from sign, degree, minute, and second
   * components.
   * The receiver is returned as a convenience.
   * @param {Boolean} neg - sign, true if negative
   * @param {Number} h - (int) hour
   * @param {Number} m - (int) minute
   * @param {Number} s - (float) second
   * @returns {Angle}
   */
  HourAngle.prototype.setDMS = function setDMS() {
    var neg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var h = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var m = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.0;

    this.angle = DMSToDeg(neg, h, m, s) * 15 * Math.PI / 180;
    return this;
  };

  /**
   * Hour returns the hour angle as hours of time.
   * @returns hour angle
   */


  HourAngle.prototype.hour = function hour() {
    return this.angle * 12 / Math.PI; // 12 = 180 / 15
  };

  HourAngle.prototype.deg = function deg() {
    return this.hour();
  };

  /**
   * Print angle in `HʰMᵐs.ssˢ`
   * @param {Number} precision - precision of `s.ss`
   * @returns {String}
   */


  HourAngle.prototype.toString = function toString(precision) {
    var _toDMS2 = this.toDMS(),
        neg = _toDMS2[0],
        h = _toDMS2[1],
        m = _toDMS2[2],
        s = _toDMS2[3];

    s = round(s, precision).toString().replace(/^0\./, '.');
    var str = (neg ? '-' : '') + (h + 'ʰ') + (m + 'ᵐ') + (s + 'ˢ');
    return str;
  };

  return HourAngle;
}(Angle);

/**
 * DMSToDeg converts from parsed sexagesimal angle components to decimal
 * degrees.
 * @param {Boolean} neg - sign, true if negative
 * @param {Number} d - (int) degree
 * @param {Number} m - (int) minute
 * @param {Number} s - (float) second
 * @returns {Number} angle in degree
 */
export function DMSToDeg(neg, d, m, s) {
  s = ((d * 60 + m) * 60 + s) / 3600;
  if (neg) {
    return -s;
  }
  return s;
}

/**
 * DegToDMS converts from decimal degrees to parsed sexagesimal angle component.
 * @param {Number} deg - angle in degree
 * @returns {Array} [neg, d, m, s]
 *  {Boolean} neg - sign, true if negative
 *  {Number} d - (int) degree
 *  {Number} m - (int) minute
 *  {Number} s - (float) second
 */
export function degToDMS(deg) {
  var neg = deg < 0;
  deg = Math.abs(deg);

  var _modf2 = modf(deg % 360),
      d = _modf2[0],
      s = _modf2[1];

  var _modf3 = modf(s * 60),
      m = _modf3[0],
      s1 = _modf3[1];

  s = round(s1 * 60); // may introduce an error < 1e13
  return [neg, d, m, s];
}

/**
 * TODO
 */
export var RA = function (_HourAngle) {
  _inherits(RA, _HourAngle);

  /**
   * constructs a new RA value from hour, minute, and second components.
   * Negative values are not supported, RA wraps values larger than 24
   * to the range [0,24) hours.
   * @param {Number} h - (int) hour
   * @param {Number} m - (int) minute
   * @param {Number} s - (float) second
   */
  function RA() {
    var h = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var m = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    _classCallCheck(this, RA);

    var _this2 = _possibleConstructorReturn(this, _HourAngle.call(this));

    var args = [].slice.call(arguments);
    if (args.length === 1) {
      _this2.angle = h;
    } else {
      var hr = DMSToDeg(false, h, m, s) % 24;
      _this2.angle = hr * 15 * Math.PI / 180;
    }
    return _this2;
  }

  RA.prototype.hour = function hour() {
    var h = this.angle * 12 / Math.PI;
    return (24 + h % 24) % 24;
  };

  return RA;
}(HourAngle);

/**
 * Time Angle
 * Unit is time in seconds.
 */
export var Time = function () {
  /**
   * @param {Boolean} neg - set `true` if negative
   * @param {Number} h - (int) hour
   * @param {Number} m - (int) minute
   * @param {Number} s - (float) second
   */
  function Time(neg, h, m, s) {
    _classCallCheck(this, Time);

    if (arguments.length === 1) {
      this.time = neg;
    } else {
      this.setHMS(neg, h, m, s);
    }
  }

  Time.prototype.setHMS = function setHMS() {
    var neg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var h = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var m = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    s += (h * 60 + m) * 60;
    if (neg) {
      s = -s;
    }
    this.time = s;
  };

  /**
   * @returns {Number} time in seconds.
   */


  Time.prototype.sec = function sec() {
    return this.time;
  };

  /**
   * @returns {Number} time in minutes.
   */


  Time.prototype.min = function min() {
    return this.time / 60;
  };

  /**
   * @returns {Number} time in hours.
   */


  Time.prototype.hour = function hour() {
    return this.time / 3600;
  };

  /**
   * @returns {Number} time in days.
   */


  Time.prototype.day = function day() {
    return this.time / 3600 / 24;
  };

  /**
   * @returns {Number} time in radians, where 1 day = 2 Pi radians.
   */


  Time.prototype.rad = function rad() {
    return this.time * Math.PI / 12 / 3600;
  };

  /**
   * convert time to HMS
   * @returns {Array} [neg, h, m, s]
   *  {Boolean} neg - sign, true if negative
   *  {Number} h - (int) hour
   *  {Number} m - (int) minute
   *  {Number} s - (float) second
   */


  Time.prototype.toHMS = function toHMS() {
    var t = this.time;
    var neg = t < 0;
    t = neg ? -t : t;
    var h = Math.trunc(t / 3600);
    t = t - h * 3600;
    var m = Math.trunc(t / 60);
    var s = t - m * 60;
    return [neg, h, m, s];
  };

  /**
   * Print time using `HʰMᵐsˢ.ss`
   * @param {Number} precision - precision of `.ss`
   * @returns {String}
   */


  Time.prototype.toString = function toString(precision) {
    var _toHMS = this.toHMS(),
        neg = _toHMS[0],
        h = _toHMS[1],
        m = _toHMS[2],
        s = _toHMS[3];

    var _modf4 = modf(s),
        si = _modf4[0],
        sf = _modf4[1];

    if (precision === 0) {
      si = round(s, 0);
      sf = 0;
    } else {
      sf = round(sf, precision).toString().substr(1);
    }
    var str = (neg ? '-' : '') + (h + 'ʰ') + (m + 'ᵐ') + (si + 'ˢ') + (sf || '');
    return str;
  };

  return Time;
}();

// units
export var angleFromDeg = function angleFromDeg(deg) {
  return deg * Math.PI / 180;
};
export var angleFromMin = function angleFromMin(min) {
  return min / 60 * Math.PI / 180;
};
export var angleFromSec = function angleFromSec(sec) {
  return sec / 3600 * Math.PI / 180;
};
export var degFromAngle = function degFromAngle(angle) {
  return angle * 180 / Math.PI;
};
export var secFromAngle = function secFromAngle(angle) {
  return angle * 3600 * 180 / Math.PI;
};
export var secFromHourAngle = function secFromHourAngle(ha) {
  return ha * 240 * 180 / Math.PI;
};

/**
 * separate fix `i` from fraction `f`
 * @private
 * @param {Number} float
 * @returns {Array} [i, f]
 *  {Number} i - (int) fix value
 *  {Number} f - (float) fractional portion; always > 1
 */
function modf(float) {
  var i = Math.trunc(float);
  var f = Math.abs(float - i);
  return [i, f];
}

/**
 * Rounds `float` value by precision
 * @private
 * @param {Number} float - value to round
 * @param {Number} precision - (int) number of post decimal positions
 * @return {Number} rounded `float`
 */
function round(float, precision) {
  precision = precision === undefined ? 10 : precision;
  return parseFloat(float.toFixed(precision), 10);
}

export default {
  Angle: Angle,
  HourAngle: HourAngle,
  DMSToDeg: DMSToDeg,
  degToDMS: degToDMS,
  RA: RA,
  Time: Time,
  angleFromDeg: angleFromDeg,
  angleFromMin: angleFromMin,
  angleFromSec: angleFromSec,
  degFromAngle: degFromAngle,
  secFromAngle: secFromAngle,
  secFromHourAngle: secFromHourAngle
};