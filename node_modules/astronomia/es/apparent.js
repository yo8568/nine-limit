/**
 * @copyright 2013 Sonia Keys
 * @copyright 2016 commenthol
 * @license MIT
 * @module apparent
 */
/**
 * Apparent: Chapter 23, Apparent Place of a Star
 */

import base from './base';
import coord from './coord';
import _nutation from './nutation';
import precess from './precess';
import solar from './solar';
var cos = Math.cos,
    tan = Math.tan;

/**
 * Nutation returns corrections due to nutation for equatorial coordinates
 * of an object.
 *
 * Results are invalid for objects very near the celestial poles.
 * @param {Number} α - right ascension
 * @param {Number} δ - declination
 * @param {Number} jd - Julian Day
 * @return {Number[]} [Δα1, Δδ1] -
*/

export function nutation(α, δ, jd) {
  // (α, δ, jd float64)  (Δα1, Δδ1 float64)
  var ε = _nutation.meanObliquity(jd);

  var _base$sincos = base.sincos(ε),
      sinε = _base$sincos[0],
      cosε = _base$sincos[1];

  var _nutation$nutation = _nutation.nutation(jd),
      Δψ = _nutation$nutation[0],
      Δε = _nutation$nutation[1];

  var _base$sincos2 = base.sincos(α),
      sinα = _base$sincos2[0],
      cosα = _base$sincos2[1];

  var tanδ = tan(δ);
  // (23.1) p. 151
  var Δα1 = (cosε + sinε * sinα * tanδ) * Δψ - cosα * tanδ * Δε;
  var Δδ1 = sinε * cosα * Δψ + sinα * Δε;
  return [Δα1, Δδ1];
}

/**
 * κ is the constant of aberration in radians.
 */
var κ = 20.49552 * Math.PI / 180 / 3600;

/**
 * longitude of perihelian of Earth's orbit.
 */
export function perihelion(T) {
  // (T float64)  float64
  return base.horner(T, 102.93735, 1.71946, 0.00046) * Math.PI / 180;
}

/**
 * EclipticAberration returns corrections due to aberration for ecliptic
 * coordinates of an object.
 */
export function eclipticAberration(λ, β, jd) {
  // (λ, β, jd float64)  (Δλ, Δβ float64)
  var T = base.J2000Century(jd);

  var _solar$trueLongitude = solar.trueLongitude(T),
      lon = _solar$trueLongitude.lon,
      ano = _solar$trueLongitude.ano; // eslint-disable-line no-unused-vars


  var e = solar.eccentricity(T);
  var π = perihelion(T);

  var _base$sincos3 = base.sincos(β),
      sβ = _base$sincos3[0],
      cβ = _base$sincos3[1];

  var _base$sincos4 = base.sincos(lon - λ),
      ssλ = _base$sincos4[0],
      csλ = _base$sincos4[1];

  var _base$sincos5 = base.sincos(π - λ),
      sinπλ = _base$sincos5[0],
      cosπλ = _base$sincos5[1];
  // (23.2) p. 151


  var Δλ = κ * (e * cosπλ - csλ) / cβ;
  var Δβ = -κ * sβ * (ssλ - e * sinπλ);
  return [Δλ, Δβ];
}

/**
 * Aberration returns corrections due to aberration for equatorial
 * coordinates of an object.
 */
export function aberration(α, δ, jd) {
  // (α, δ, jd float64)  (Δα2, Δδ2 float64)
  var ε = _nutation.meanObliquity(jd);
  var T = base.J2000Century(jd);

  var _solar$trueLongitude2 = solar.trueLongitude(T),
      lon = _solar$trueLongitude2.lon,
      ano = _solar$trueLongitude2.ano; // eslint-disable-line no-unused-vars


  var e = solar.eccentricity(T);
  var π = perihelion(T);

  var _base$sincos6 = base.sincos(α),
      sinα = _base$sincos6[0],
      cosα = _base$sincos6[1];

  var _base$sincos7 = base.sincos(δ),
      sinδ = _base$sincos7[0],
      cosδ = _base$sincos7[1];

  var _base$sincos8 = base.sincos(lon),
      sins = _base$sincos8[0],
      coss = _base$sincos8[1];

  var _base$sincos9 = base.sincos(π),
      sinπ = _base$sincos9[0],
      cosπ = _base$sincos9[1];

  var cosε = cos(ε);
  var q1 = cosα * cosε;
  // (23.3) p. 152
  var Δα2 = κ * (e * (q1 * cosπ + sinα * sinπ) - (q1 * coss + sinα * sins)) / cosδ;
  var q2 = cosε * (tan(ε) * cosδ - sinα * sinδ);
  var q3 = cosα * sinδ;
  var Δδ2 = κ * (e * (cosπ * q2 + sinπ * q3) - (coss * q2 + sins * q3));
  return [Δα2, Δδ2];
}

/**
 * Position computes the apparent position of an object.
 *
 * Position is computed for equatorial coordinates in eqFrom, considering
 * proper motion, precession, nutation, and aberration.  Result is in
 * eqTo.  EqFrom and eqTo must be non-nil, but may point to the same struct.
 */
export function position(eqFrom, epochFrom, epochTo, mα, mδ) {
  // (eqFrom, eqTo *coord.Equatorial, epochFrom, epochTo float64, mα sexa.HourAngle, mδ sexa.Angle)  *coord.Equatorial
  var eqTo = precess.position(eqFrom, epochFrom, epochTo, mα, mδ);
  var jd = base.JulianYearToJDE(epochTo);

  var _nutation2 = nutation(eqTo.ra, eqTo.dec, jd),
      Δα1 = _nutation2[0],
      Δδ1 = _nutation2[1];

  var _aberration = aberration(eqTo.ra, eqTo.dec, jd),
      Δα2 = _aberration[0],
      Δδ2 = _aberration[1];

  eqTo.ra += Δα1 + Δα2;
  eqTo.dec += Δδ1 + Δδ2;
  return eqTo;
}

/**
 * AberrationRonVondrak uses the Ron-Vondrák expression to compute corrections
 * due to aberration for equatorial coordinates of an object.
 */
export function aberrationRonVondrak(α, δ, jd) {
  // (α, δ, jd float64)  (Δα, Δδ float64)
  var T = base.J2000Century(jd);
  var r = {
    T: T,
    L2: 3.1761467 + 1021.3285546 * T,
    L3: 1.7534703 + 628.3075849 * T,
    L4: 6.2034809 + 334.0612431 * T,
    L5: 0.5995465 + 52.9690965 * T,
    L6: 0.8740168 + 21.3299095 * T,
    L7: 5.4812939 + 7.4781599 * T,
    L8: 5.3118863 + 3.8133036 * T,
    Lp: 3.8103444 + 8399.6847337 * T,
    D: 5.1984667 + 7771.3771486 * T,
    Mp: 2.3555559 + 8328.6914289 * T,
    F: 1.6279052 + 8433.4661601 * T
  };
  var Xp = 0;
  var Yp = 0;
  var Zp = 0;
  // sum smaller terms first
  for (var i = 35; i >= 0; i--) {
    var _rvTerm$i = rvTerm[i](r),
        x = _rvTerm$i[0],
        y = _rvTerm$i[1],
        z = _rvTerm$i[2];

    Xp += x;
    Yp += y;
    Zp += z;
  }

  var _base$sincos10 = base.sincos(α),
      sinα = _base$sincos10[0],
      cosα = _base$sincos10[1];

  var _base$sincos11 = base.sincos(δ),
      sinδ = _base$sincos11[0],
      cosδ = _base$sincos11[1];
  // (23.4) p. 156


  return [(Yp * cosα - Xp * sinα) / (c * cosδ), -((Xp * cosα + Yp * sinα) * sinδ - Zp * cosδ) / c];
}

var c = 17314463350; // unit is 1e-8 AU / day

// r = {T, L2, L3, L4, L5, L6, L7, L8, Lp, D, Mp, F}
var rvTerm = [function (r) {
  // 1
  var _base$sincos12 = base.sincos(r.L3),
      sinA = _base$sincos12[0],
      cosA = _base$sincos12[1];

  return [(-1719914 - 2 * r.T) * sinA - 25 * cosA, (25 - 13 * r.T) * sinA + (1578089 + 156 * r.T) * cosA, (10 + 32 * r.T) * sinA + (684185 - 358 * r.T) * cosA];
}, function (r) {
  // 2
  var _base$sincos13 = base.sincos(2 * r.L3),
      sinA = _base$sincos13[0],
      cosA = _base$sincos13[1];

  return [(6434 + 141 * r.T) * sinA + (28007 - 107 * r.T) * cosA, (25697 - 95 * r.T) * sinA + (-5904 - 130 * r.T) * cosA, (11141 - 48 * r.T) * sinA + (-2559 - 55 * r.T) * cosA];
}, function (r) {
  // 3
  var _base$sincos14 = base.sincos(r.L5),
      sinA = _base$sincos14[0],
      cosA = _base$sincos14[1];

  return [715 * sinA, 6 * sinA - 657 * cosA, -15 * sinA - 282 * cosA];
}, function (r) {
  // 4
  var _base$sincos15 = base.sincos(r.Lp),
      sinA = _base$sincos15[0],
      cosA = _base$sincos15[1];

  return [715 * sinA, -656 * cosA, -285 * cosA];
}, function (r) {
  // 5
  var _base$sincos16 = base.sincos(3 * r.L3),
      sinA = _base$sincos16[0],
      cosA = _base$sincos16[1];

  return [(486 - 5 * r.T) * sinA + (-236 - 4 * r.T) * cosA, (-216 - 4 * r.T) * sinA + (-446 + 5 * r.T) * cosA, -94 * sinA - 193 * cosA];
}, function (r) {
  // 6
  var _base$sincos17 = base.sincos(r.L6),
      sinA = _base$sincos17[0],
      cosA = _base$sincos17[1];

  return [159 * sinA, 2 * sinA - 147 * cosA, -6 * sinA - 61 * cosA];
}, function (r) {
  // 7
  var cosA = Math.cos(r.F);
  return [0, 26 * cosA, -59 * cosA];
}, function (r) {
  // 8
  var _base$sincos18 = base.sincos(r.Lp + r.Mp),
      sinA = _base$sincos18[0],
      cosA = _base$sincos18[1];

  return [39 * sinA, -36 * cosA, -16 * cosA];
}, function (r) {
  // 9
  var _base$sincos19 = base.sincos(2 * r.L5),
      sinA = _base$sincos19[0],
      cosA = _base$sincos19[1];

  return [33 * sinA - 10 * cosA, -9 * sinA - 30 * cosA, -5 * sinA - 13 * cosA];
}, function (r) {
  // 10
  var _base$sincos20 = base.sincos(2 * r.L3 - r.L5),
      sinA = _base$sincos20[0],
      cosA = _base$sincos20[1];

  return [31 * sinA + cosA, sinA - 28 * cosA, -12 * cosA];
}, function (r) {
  // 11
  var _base$sincos21 = base.sincos(3 * r.L3 - 8 * r.L4 + 3 * r.L5),
      sinA = _base$sincos21[0],
      cosA = _base$sincos21[1];

  return [8 * sinA - 28 * cosA, 25 * sinA + 8 * cosA, 11 * sinA + 3 * cosA];
}, function (r) {
  // 12
  var _base$sincos22 = base.sincos(5 * r.L3 - 8 * r.L4 + 3 * r.L5),
      sinA = _base$sincos22[0],
      cosA = _base$sincos22[1];

  return [8 * sinA - 28 * cosA, -25 * sinA - 8 * cosA, -11 * sinA + -3 * cosA];
}, function (r) {
  // 13
  var _base$sincos23 = base.sincos(2 * r.L2 - r.L3),
      sinA = _base$sincos23[0],
      cosA = _base$sincos23[1];

  return [21 * sinA, -19 * cosA, -8 * cosA];
}, function (r) {
  // 14
  var _base$sincos24 = base.sincos(r.L2),
      sinA = _base$sincos24[0],
      cosA = _base$sincos24[1];

  return [-19 * sinA, 17 * cosA, 8 * cosA];
}, function (r) {
  // 15
  var _base$sincos25 = base.sincos(r.L7),
      sinA = _base$sincos25[0],
      cosA = _base$sincos25[1];

  return [17 * sinA, -16 * cosA, -7 * cosA];
}, function (r) {
  // 16
  var _base$sincos26 = base.sincos(r.L3 - 2 * r.L5),
      sinA = _base$sincos26[0],
      cosA = _base$sincos26[1];

  return [16 * sinA, 15 * cosA, sinA + 7 * cosA];
}, function (r) {
  // 17
  var _base$sincos27 = base.sincos(r.L8),
      sinA = _base$sincos27[0],
      cosA = _base$sincos27[1];

  return [16 * sinA, sinA - 15 * cosA, -3 * sinA - 6 * cosA];
}, function (r) {
  // 18
  var _base$sincos28 = base.sincos(r.L3 + r.L5),
      sinA = _base$sincos28[0],
      cosA = _base$sincos28[1];

  return [11 * sinA - cosA, -sinA - 10 * cosA, -sinA - 5 * cosA];
}, function (r) {
  // 19
  var _base$sincos29 = base.sincos(2 * r.L2 - 2 * r.L3),
      sinA = _base$sincos29[0],
      cosA = _base$sincos29[1];

  return [-11 * cosA, -10 * sinA, -4 * sinA];
}, function (r) {
  // 20
  var _base$sincos30 = base.sincos(r.L3 - r.L5),
      sinA = _base$sincos30[0],
      cosA = _base$sincos30[1];

  return [-11 * sinA - 2 * cosA, -2 * sinA + 9 * cosA, -sinA + 4 * cosA];
}, function (r) {
  // 21
  var _base$sincos31 = base.sincos(4 * r.L3),
      sinA = _base$sincos31[0],
      cosA = _base$sincos31[1];

  return [-7 * sinA - 8 * cosA, -8 * sinA + 6 * cosA, -3 * sinA + 3 * cosA];
}, function (r) {
  // 22
  var _base$sincos32 = base.sincos(3 * r.L3 - 2 * r.L5),
      sinA = _base$sincos32[0],
      cosA = _base$sincos32[1];

  return [-10 * sinA, 9 * cosA, 4 * cosA];
}, function (r) {
  // 23
  var _base$sincos33 = base.sincos(r.L2 - 2 * r.L3),
      sinA = _base$sincos33[0],
      cosA = _base$sincos33[1];

  return [-9 * sinA, -9 * cosA, -4 * cosA];
}, function (r) {
  // 24
  var _base$sincos34 = base.sincos(2 * r.L2 - 3 * r.L3),
      sinA = _base$sincos34[0],
      cosA = _base$sincos34[1];

  return [-9 * sinA, -8 * cosA, -4 * cosA];
}, function (r) {
  // 25
  var _base$sincos35 = base.sincos(2 * r.L6),
      sinA = _base$sincos35[0],
      cosA = _base$sincos35[1];

  return [-9 * cosA, -8 * sinA, -3 * sinA];
}, function (r) {
  // 26
  var _base$sincos36 = base.sincos(2 * r.L2 - 4 * r.L3),
      sinA = _base$sincos36[0],
      cosA = _base$sincos36[1];

  return [-9 * cosA, 8 * sinA, 3 * sinA];
}, function (r) {
  // 27
  var _base$sincos37 = base.sincos(3 * r.L3 - 2 * r.L4),
      sinA = _base$sincos37[0],
      cosA = _base$sincos37[1];

  return [8 * sinA, -8 * cosA, -3 * cosA];
}, function (r) {
  // 28
  var _base$sincos38 = base.sincos(r.Lp + 2 * r.D - r.Mp),
      sinA = _base$sincos38[0],
      cosA = _base$sincos38[1];

  return [8 * sinA, -7 * cosA, -3 * cosA];
}, function (r) {
  // 29
  var _base$sincos39 = base.sincos(8 * r.L2 - 12 * r.L3),
      sinA = _base$sincos39[0],
      cosA = _base$sincos39[1];

  return [-4 * sinA - 7 * cosA, -6 * sinA + 4 * cosA, -3 * sinA + 2 * cosA];
}, function (r) {
  // 30
  var _base$sincos40 = base.sincos(8 * r.L2 - 14 * r.L3),
      sinA = _base$sincos40[0],
      cosA = _base$sincos40[1];

  return [-4 * sinA - 7 * cosA, 6 * sinA - 4 * cosA, 3 * sinA - 2 * cosA];
}, function (r) {
  // 31
  var _base$sincos41 = base.sincos(2 * r.L4),
      sinA = _base$sincos41[0],
      cosA = _base$sincos41[1];

  return [-6 * sinA - 5 * cosA, -4 * sinA + 5 * cosA, -2 * sinA + 2 * cosA];
}, function (r) {
  // 32
  var _base$sincos42 = base.sincos(3 * r.L2 - 4 * r.L3),
      sinA = _base$sincos42[0],
      cosA = _base$sincos42[1];

  return [-sinA - cosA, -2 * sinA - 7 * cosA, sinA - 4 * cosA];
}, function (r) {
  // 33
  var _base$sincos43 = base.sincos(2 * r.L3 - 2 * r.L5),
      sinA = _base$sincos43[0],
      cosA = _base$sincos43[1];

  return [4 * sinA - 6 * cosA, -5 * sinA - 4 * cosA, -2 * sinA - 2 * cosA];
}, function (r) {
  // 34
  var _base$sincos44 = base.sincos(3 * r.L2 - 3 * r.L3),
      sinA = _base$sincos44[0],
      cosA = _base$sincos44[1];

  return [-7 * cosA, -6 * sinA, -3 * sinA];
}, function (r) {
  // 35
  var _base$sincos45 = base.sincos(2 * r.L3 - 2 * r.L4),
      sinA = _base$sincos45[0],
      cosA = _base$sincos45[1];

  return [5 * sinA - 5 * cosA, -4 * sinA - 5 * cosA, -2 * sinA - 2 * cosA];
}, function (r) {
  // 36
  var _base$sincos46 = base.sincos(r.Lp - 2 * r.D),
      sinA = _base$sincos46[0],
      cosA = _base$sincos46[1];

  return [5 * sinA, -5 * cosA, -2 * cosA];
}];

/**
 * PositionRonVondrak computes the apparent position of an object using
 * the Ron-Vondrák expression for aberration.
 *
 * Position is computed for equatorial coordinates in eqFrom, considering
 * proper motion, aberration, precession, and _nutation.  Result is in
 * eqTo.  EqFrom and eqTo must be non-nil, but may point to the same struct.
 *
 * Note the Ron-Vondrák expression is only valid for the epoch J2000.
 * EqFrom must be coordinates at epoch J2000.
 */
export function positionRonVondrak(eqFrom, epochTo, mα, mδ) {
  // (eqFrom, eqTo *coord.Equatorial, epochTo float64, mα sexa.HourAngle, mδ sexa.Angle)  *coord.Equatorial
  var t = epochTo - 2000;
  var eqTo = new coord.Equatorial();
  eqTo.ra = eqFrom.ra + mα.rad() * t;
  eqTo.dec = eqFrom.dec + mδ.rad() * t;
  var jd = base.JulianYearToJDE(epochTo);

  var _aberrationRonVondrak = aberrationRonVondrak(eqTo.ra, eqTo.dec, jd),
      Δα = _aberrationRonVondrak[0],
      Δδ = _aberrationRonVondrak[1];

  eqTo.ra += Δα;
  eqTo.dec += Δδ;
  eqTo = precess.position(eqTo, 2000, epochTo, 0, 0);

  var _nutation3 = nutation(eqTo.ra, eqTo.dec, jd),
      Δα1 = _nutation3[0],
      Δδ1 = _nutation3[1];

  eqTo.ra += Δα1;
  eqTo.dec += Δδ1;
  return eqTo;
}

export default {
  nutation: nutation,
  perihelion: perihelion,
  eclipticAberration: eclipticAberration,
  aberration: aberration,
  position: position,
  aberrationRonVondrak: aberrationRonVondrak,
  positionRonVondrak: positionRonVondrak
};