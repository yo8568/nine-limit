/**
 * @copyright 2013 Sonia Keys
 * @copyright 2016 commenthol
 * @license MIT
 * @module fit
 */
/**
 * Fit: Chapter 4, Curve Fitting.
 */

/**
 * Linear fits a line to sample data.
 *
 * Argument p is a list of data points.  Results a and b are coefficients
 * of the best fit line y = ax + b.
 */
export function linear(points) {
  // (p []struct{ X, Y float64 })  (a, b float64)
  var sx = 0;
  var sy = 0;
  var sx2 = 0;
  var sxy = 0;
  for (var _iterator = points, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var p = _ref;

    var x = p.x;
    var y = p.y;
    sx += x;
    sy += y;
    sx2 += x * x;
    sxy += x * y;
  }
  var n = points.length;
  var d = n * sx2 - sx * sx;
  // (4.2) p. 36
  var a = (n * sxy - sx * sy) / d;
  var b = (sy * sx2 - sx * sxy) / d;
  return [a, b];
}

/**
 * CorrelationCoefficient returns a correlation coefficient for sample data.
 */
export function correlationCoefficient(points) {
  // (p []struct{ X, Y float64 })  float64
  var sx = 0;
  var sy = 0;
  var sx2 = 0;
  var sy2 = 0;
  var sxy = 0;
  for (var _iterator2 = points, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
    var _ref2;

    if (_isArray2) {
      if (_i2 >= _iterator2.length) break;
      _ref2 = _iterator2[_i2++];
    } else {
      _i2 = _iterator2.next();
      if (_i2.done) break;
      _ref2 = _i2.value;
    }

    var p = _ref2;

    var x = p.x;
    var y = p.y;
    sx += x;
    sy += y;
    sx2 += x * x;
    sy2 += y * y;
    sxy += x * y;
  }
  var n = points.length;
  // (4.3) p. 38
  return (n * sxy - sx * sy) / (Math.sqrt(n * sx2 - sx * sx) * Math.sqrt(n * sy2 - sy * sy));
}

/**
 * Quadratic fits y = ax² + bx + c to sample data.
 *
 * Argument p is a list of data points.  Results a, b, and c are coefficients
 * of the best fit quadratic y = ax² + bx + c.
 */
export function quadratic(points) {
  var P = 0;
  var Q = 0;
  var R = 0;
  var S = 0;
  var T = 0;
  var U = 0;
  var V = 0;
  for (var _iterator3 = points, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
    var _ref3;

    if (_isArray3) {
      if (_i3 >= _iterator3.length) break;
      _ref3 = _iterator3[_i3++];
    } else {
      _i3 = _iterator3.next();
      if (_i3.done) break;
      _ref3 = _i3.value;
    }

    var p = _ref3;

    var x = p.x;
    var y = p.y;
    var x2 = x * x;
    P += x;
    Q += x2;
    R += x * x2;
    S += x2 * x2;
    T += y;
    U += x * y;
    V += x2 * y;
  }
  var N = points.length;
  // (4.5) p. 43
  var D = N * Q * S + 2 * P * Q * R - Q * Q * Q - P * P * S - N * R * R;
  // (4.6) p. 43
  var a = (N * Q * V + P * R * T + P * Q * U - Q * Q * T - P * P * V - N * R * U) / D;
  var b = (N * S * U + P * Q * V + Q * R * T - Q * Q * U - P * S * T - N * R * V) / D;
  var c = (Q * S * T + Q * R * U + P * R * V - Q * Q * V - P * S * U - R * R * T) / D;
  return [a, b, c];
}

/**
 * Func3 implements multiple linear regression for a linear combination
 * of three functions.
 *
 * Given sample data and three functions in x, Func3 returns coefficients
 * a, b, and c fitting y = aƒ₀(x) + bƒ₁(x) + cƒ₂(x) to sample data.
 */
export function func3(points, f0, f1, f2) {
  var M = 0;
  var P = 0;
  var Q = 0;
  var R = 0;
  var S = 0;
  var T = 0;
  var U = 0;
  var V = 0;
  var W = 0;
  for (var _iterator4 = points, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
    var _ref4;

    if (_isArray4) {
      if (_i4 >= _iterator4.length) break;
      _ref4 = _iterator4[_i4++];
    } else {
      _i4 = _iterator4.next();
      if (_i4.done) break;
      _ref4 = _i4.value;
    }

    var p = _ref4;

    var x = p.x;
    var y = p.y;
    var y0 = f0(x);
    var y1 = f1(x);
    var y2 = f2(x);
    M += y0 * y0;
    P += y0 * y1;
    Q += y0 * y2;
    R += y1 * y1;
    S += y1 * y2;
    T += y2 * y2;
    U += y * y0;
    V += y * y1;
    W += y * y2;
  }
  // (4.7) p. 44
  var D = M * R * T + 2 * P * Q * S - M * S * S - R * Q * Q - T * P * P;
  var a = (U * (R * T - S * S) + V * (Q * S - P * T) + W * (P * S - Q * R)) / D;
  var b = (U * (S * Q - P * T) + V * (M * T - Q * Q) + W * (P * Q - M * S)) / D;
  var c = (U * (P * S - R * Q) + V * (P * Q - M * S) + W * (M * R - P * P)) / D;
  return [a, b, c];
}

/**
 * Func1 fits a linear multiple of a function to sample data.
 *
 * Given sample data and a function in x, Func1 returns coefficient
 * a fitting y = aƒ(x).
 */
export function func1(points, f) {
  var syf = 0;
  var sf2 = 0;
  // (4.8) p. 45
  for (var _iterator5 = points, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
    var _ref5;

    if (_isArray5) {
      if (_i5 >= _iterator5.length) break;
      _ref5 = _iterator5[_i5++];
    } else {
      _i5 = _iterator5.next();
      if (_i5.done) break;
      _ref5 = _i5.value;
    }

    var p = _ref5;

    var fx = f(p.x);
    var y = p.y;
    syf += y * fx;
    sf2 += fx * fx;
  }
  return syf / sf2;
}

export default {
  linear: linear,
  correlationCoefficient: correlationCoefficient,
  quadratic: quadratic,
  func3: func3,
  func1: func1
};