var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @copyright 2013 Sonia Keys
 * @copyright 2016 commenthol
 * @license MIT
 * @module planetposition
 */
/**
 * Planetposition: Chapter 32, Positions of the Planets.
 *
 * Incomplete:
 *
 * 1. The package does not implement algorithms that use appendix III,
 * but instead implements a full VSOP87 solution.  I do not have a copy
 * of the supplimentary disk with appendix III in machine readable form
 * and as the appendix is rather large, retyping it by hand is problematic.
 * The full VSOP87 data set on the other hand is freely downloadable from
 * the internet, so I implement here code that can use that data directly.
 *
 * 2. The formula for accuracy of results is not implemented.  It is
 * not needed for full VSOP87 solutions.
 *
 * 3. Polynomial expressions are not implemented.  Again, implementation
 * would involve typing rather large tables of numbers with associated
 * risk of typographical errors.
 */

import base from './base';
import sexa from './sexagesimal';
import coord from './coord';
import precess from './precess';

function sum(t, series) {
  var coeffs = [];
  Object.keys(series).forEach(function (x) {
    coeffs[x] = 0;
    var y = series[x].length - 1;
    for (y; y >= 0; y--) {
      var term = {
        a: series[x][y][0],
        b: series[x][y][1],
        c: series[x][y][2]
      };
      coeffs[x] += term.a * Math.cos(term.b + term.c * t);
    }
  });
  var res = base.horner(t, coeffs);
  return res;
}

export var Planet = function () {
  /**
   * VSOP87 representation of a Planet
   * @constructs Planet
   * @param {object} planet - planet data series
   * @example
   * ```js
   * // for use in browser
   * import {data} from 'astronomia'
   * const earth = new planetposition.Planet(data.vsop87Bearth)
   * ```
   */
  function Planet(planet) {
    _classCallCheck(this, Planet);

    if ((typeof planet === 'undefined' ? 'undefined' : _typeof(planet)) !== 'object') throw new TypeError('need planet vsop87 data');
    this.name = planet.name;
    this.series = planet;
  }

  /**
   * Position2000 returns ecliptic position of planets by full VSOP87 theory.
   *
   * @param {Number} jde - the date for which positions are desired.
   * @returns {base.Coord} Results are for the dynamical equinox and ecliptic J2000.
   *  {Number} lon - heliocentric longitude in radians.
   *  {Number} lat - heliocentric latitude in radians.
   *  {Number} range - heliocentric range in AU.
   */


  Planet.prototype.position2000 = function position2000(jde) {
    var T = base.J2000Century(jde);
    var τ = T * 0.1;
    var lon = base.pmod(sum(τ, this.series.L), 2 * Math.PI);
    var lat = sum(τ, this.series.B);
    var range = sum(τ, this.series.R);
    return new base.Coord(lon, lat, range);
  };

  /**
   * Position returns ecliptic position of planets at equinox and ecliptic of date.
   *
   * @param {Number} jde - the date for which positions are desired.
   * @returns {base.Coord} Results are positions consistent with those from Meeus's
   * Apendix III, that is, at equinox and ecliptic of date.
   *  {Number} lon - heliocentric longitude in radians.
   *  {Number} lat - heliocentric latitude in radians.
   *  {Number} range - heliocentric range in AU.
   */


  Planet.prototype.position = function position(jde) {
    var _position = this.position2000(jde),
        lat = _position.lat,
        lon = _position.lon,
        range = _position.range;

    var eclFrom = new coord.Ecliptic(lon, lat);
    var epochFrom = 2000.0;
    var epochTo = base.JDEToJulianYear(jde);
    var eclTo = precess.eclipticPosition(eclFrom, epochFrom, epochTo, 0, 0);
    return new base.Coord(eclTo.lon, eclTo.lat, range);
  };

  return Planet;
}();

/**
 * ToFK5 converts ecliptic longitude and latitude from dynamical frame to FK5.
 *
 * @param {Number} lon - ecliptic longitude in radians
 * @param {Number} lat - ecliptic latitude in radians
 * @param {Number} jde - Julian ephemeris day
 * @return {base.Coord}
 *    {Number} lon - FK5 longitude
 *    {Number} lat - FK5 latitude
 */
export function toFK5(lon, lat, jde) {
  // formula 32.3, p. 219.
  var T = base.J2000Century(jde);
  // const Lp = lon - 1.397 * Math.PI / 180 * T - 0.00031 * Math.PI / 180 * T * T
  var Lp = lon - sexa.angleFromDeg((1.397 + 0.00031 * T) * T);

  var _base$sincos = base.sincos(Lp),
      sLp = _base$sincos[0],
      cLp = _base$sincos[1];
  // (32.3) p. 219


  var L5 = lon + sexa.angleFromSec(-0.09033 + 0.03916 * (cLp + sLp) * Math.tan(lat));
  var B5 = lat + sexa.angleFromSec(0.03916 * (cLp - sLp));
  return new base.Coord(L5, B5);
}

export default {
  Planet: Planet,
  toFK5: toFK5
};